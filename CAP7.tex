%!TEX root = origin.TEX
\appendix
\chapter{Pseudocódigo del Diseño de Red}
\begin{algorithm}
\SetAlgoLined

{$entradas\gets Tensor(LoteImagenes, Anchura, Altura, Profundidad)$}\;
{$salidaDeseada\gets Tensor(LoteImagenes,NumeroClases)$}\;
{$numFiltrosEntradaCapa_N\gets 1;$}\

\While{$N < numCapasConvolucionales$}{
	$capaConv_N, pesosConv_N \gets\textbf{capaConvolucion(} $\
		$datosImagen = entradas,$\
        $numCanales = numFiltrosEntradaCapa_N,$\
        $tamFiltro = tamFiltroCapa_N,$\
        $numFiltros=numFiltrosSalidaCapa_N,$\newline
        $usarPooling=True$\newline
        $\textbf{)}$;\newline
    
    $capaConvDropOut_N \gets dropout(capaconv_N, dropoutConv_N);$\\
    $entradas \gets capaConvDropOut_N;$\\
    $numFiltrosEntradaCapa_N\gets numFiltrosSalidaCapa_N;$\\
}

\BlankLine
\While{$N < (numCapasConvolucionales -1) $}{
	$capaConvDropOut_N \gets\textbf{ejecutarPooling(} $\
		$data = capaConvDropOut_N,$\newline
        $tamFiltro = 2^\text{( numCapasConvolucionales - N)}$\newline
        $\textbf{)}$;\newline
    
    $datosCapa_N \gets (datosCapa_N + capaConvDropOut_N[Anchura] * capaConvDropOut_N[Altura] * capaConvDropOut_N[Profundidad]);$\\
    $capaSalida \gets (capaSalida + capaConvDropOut_N)$;
}

\BlankLine
$capaFC1, pesosFC1 \gets \textbf{capaTotalmenteConectada(}$\
$datosImagen = capaSalida,$\newline
$numCanales = datosCapa_N,$\newline
$tamFiltro = numSalidas,   ..... [Dadas Aleatoriamente]$\newline
$usarRELU=True\textbf{)};$\newline


$capaFC1dropOut\gets dropout(capaFC1, dropoutFC1=0.5);$\newline

$capaFC2, pesosFC2 \gets\textbf{capaTotalmenteConectada(} $\
$datosImagen = capaFC1dropOut,$\newline
$numCanales = numSalidas,$\newline
$tamFiltro = numClases, $\newline
$usarRELU=False\textbf{)};$\newline


$salidacalculada \gets \textbf{softmax}(capaFC2)$\;
$error \gets \textbf{entropiaCruzada}(salidacalculada,salidadeseada)$\;
$optimizador\gets \textbf{Adam}(TasaAprendizaje).minimize(error,iterac)$\;


\caption{Función Principal}
\end{algorithm}



\newpage
\begin{procedure}[H]
	\KwIn{datosImagen, numCanales, tamFiltro, numFiltros, usarPooling}
	\KwOut{MatrizConvolucion, pesos}
	\BlankLine
	$forma\gets [tamFiltro, tamFiltro, numCanales, numFiltros];$\\
	$pesos\gets inicializarPesos(forma);$\\
	$biases\gets inicializarBias(numFiltros);$\\
	$convolucion \gets convolucion2D($\
	$input = datosImagen,$\newline
	$filter=pesos,$\newline
	$formaPadding=[1, 1, 1, 1],$\newline
	$padding=activado);$\\

	$convolucion\gets convolucion + biases;$\\
	$convolucion\gets funcionRELU(convolucion);$\\

	\If{usarPooling = True}{
		$convolucion\gets ejecutarPooling(convolucion,2);$\\
	}
	\textbf{return} $(convolucion, pesos)$
	\caption{capaConvolucion (Img, numCanales, tamFiltro, numFiltro, usarPool)}
\end{procedure}


\vskip 0.7cm
\begin{procedure}[H]
	\KwIn{datos de Convolucion}
	\KwOut{Datos con funcion RELU aplicada}
	\BlankLine
	\ForEach{item in datosDeConvolucion}{$nuevosDatos[i] \gets max(datosDeConvolucion[i],0);$	}
	\textbf{return} $nuevosDatos$
	\caption{FuncionRELU (datosDeConvolucion)}
\end{procedure}



\vskip 0.7cm
\begin{procedure}[H]
	\KwIn{Vector de Salida Calculada y vector de Salida Deseada}
	\KwOut{Validación Cruzada de Vectores}
	\BlankLine
	$crossEntropy\gets -suma(vectorSalidaDeseada * nlog(vectorSalidaCalculada));$\\
	\textbf{return} $crossentropy$
	\caption{entropiaCruzada (vectorSalidaCalculada,vectorSalidaDeseada)}
\end{procedure}


\vskip 0.7cm
\begin{procedure}[H]
	\KwIn{Vector de datos}
	\KwOut{Vector de datos entre 0 y 1}
	\BlankLine
	\textbf{return} ${e^{\mathbf {vectorDatos}}} / {\sum _{k=1}^{K}e^{vectorDatos}};$
	\caption{softmax (vectorDatos)}
\end{procedure}



\begin{procedure}[H]
	\KwIn{entrada, numEntradas, numSalidas, usarRELU}
	\KwOut{Vector de datos Resultantes, pesos por Item del Vector}
	\BlankLine
	$pesos\gets inicializarPesos([numEntradas, numSalidas]);$\\
	$biases\gets inicializarBias(numSalidas);$\\
	$capaFC\gets (entrada * pesos) + biases;$\\


	\If{usarRELU = True}{
		$capaFC \gets funcionRELU(capaFC);$\\
	}
	\textbf{return} $(capaFC, pesos)$
	\caption{capaTotalmenteConectada (entrada,numEntradas,numSalidas,usarRELU)}
\end{procedure}

Código de la implemantación completa ubicado en: https://github.com/jtavara23/SignalsWindows